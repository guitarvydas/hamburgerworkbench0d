<!DOCTYPE html>
<html>
  <head>
    <style>
      textarea {
          background-color: oldlace;
      }
    </style>
  </head>
  <body>

    <h1>Hamburger 0D Workbench</h1>

    <p>markdown grammar:</p>
    <textarea id="grammar" rows="15" cols="90" placeholder="grammar">
hamburger {
Main = Phrase+

Phrase =
  | "I" "Want" "A" "Hamburger" "With" Choice* -- longphrase
  | "I" "Want" "A" "Cheeseburger"             -- shortphrase
  
Choice = "And"? (Condiment | Extra)
  
Condiment =
 | "Mustard"         -- mustard
 | "Ketchup"         -- ketchup
 | "Pickles"         -- pickles
 | "Special" "Sauce" -- specialsauce
 
Extra =
 | "Cheese"          -- cheese
 | "Bacon"           -- bacon
 
}
    </textarea>

    <p>source:</p>
    <textarea id="source" rows="7" cols="90" placeholder="input">
      I Want A Cheeseburger
      I Want A Hamburger With Cheese And Special Sauce And Ketchup
    </textarea>
    <p>output:</p>
    <textarea id="output" rows="7" cols="90" placeholder="output">
    </textarea>


    <p id="status" >READY</p>


    <br>
    <button onclick="htmlbutton.handler (htmlbutton, null)">Hamburger</button>
    <script src="https://unpkg.com/ohm-js@16/dist/ohm.min.js"></script>
    <script>

      function foldChoices (a) {
	  let condiments = [];
	  let extras = [];
	  a.forEach (choiceObj => {
	      choiceObj.condiments [0] && condiments.push (choiceObj.condiments [0]);
	      choiceObj.extras [0] && extras.push (choiceObj.extras [0]);
	  });
	  return {condiments: condiments, extras: extras};
      }

      let hamburger_hooks = {
          // bits of action code ("semantics") to hang off
          // like Christmas tree ornaments from the main parse
          // tree (an AST which becomes a CST when applied
          //  to actual input text).

          Main: function (p) { return p.hamburger (); },
          Phrase_longphrase: function (sI, sWant, sA, sHamburger, sWith, choiceArray) {
	      
              let c = foldChoices (choiceArray.hamburger ());
	      c.long = true;
	      return c;
          },
          Phrase_shortphrase: function (sI, sWant, sA, sCheeseburger) {
              return { condiments: [], extras: [], short: true};
          },
          Choice: function (optAnd, ch) {
              return ch.hamburger ();
          },
          Condiment_ketchup: function (c) {
              return { condiments: ["ketchup"],  extras: [] };
          },
          Condiment_mustard: function (c) {
              return { condiments: ["mustard"],  extras: [] };
          },
          Condiment_pickles: function (c) {
              return { condiments: ["pickles"],  extras: [] };
          },
          Condiment_specialsauce: function (c1, c2) {
              return { condiments: ["special sauce"],  extras: [] };
          },
          Extra_cheese: function (_) {
              return { condiments: [],  extras: ["cheese"] };
          },
          Extra_bacon: function (_) {
              return { condiments: [],  extras: ["bacon"] };
          },
          _terminal: function () {
              return { content: this.sourceString};
          },
          _iter: function (...children) { 
              let arr = children.map(c => {
                  return c.hamburger ()
              }); 
              return arr;
          }
      };
      
      function parse () {
          let grammarText = document.getElementById("grammar").value;
          let src = document.getElementById("source").value;
          let g = ohm.grammar (grammarText);
          let matchResult = g.match (src);
          if (matchResult.succeeded ()) {
              document.getElementById("status").innerHTML 
                  = "OK";
              let s = g.createSemantics ();
              return [matchResult, s];
          } else {
              document.getElementById("status").innerHTML 
                  = "parse FAILED";
              let dontcare = null;
              return [ matchResult, dontcare ];
          }
      }

      function transpileHamburgerOrder (phrase) {
          var [cst, hookMap] = parsePhrase (phrase);      
          if (cst.succeeded ()) {
              hookMap.addOperation ('hamburger', hamburger_hooks);
              let treeWalker = hookMap (cst);
              let oorder = treeWalker.hamburger ();
	      return order;
          } else {
              document.getElementById ('output').innerHTML 
                  = 'FAILED';
          }
      }
      
      var protoHTMLbutton = require ('./htmlbutton');
      var htmlbutton = new protoHTMLbutton.HTMLbutton (me);

      var protoPhraseFaker = require ('./phrasefaker');
      var phraseFaker = new protoPhraseFaker.PhraseFaker (me);

      var protoPhraseParser = require ('./phraseparser');
      var phraseParser = new protoPhraseParser.PhraseParser (me);

      var protoOrderTaker = require ('./ordertaker');
      var orderTaker = new protoOrderTaker.OrderTaker (me);

      var protoTestBench = require ('./testbench');
      var testBench = new protoOrderTaker.TestBench (null);

    </script>
  </body>
</html>

